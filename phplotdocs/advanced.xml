<!-- $Id$
     PHPlot Advanced Programming Topics
     Note: The "callbacks" section used to be its own chapter. Other material
     was moved from the "concepts" chapter. The IDs (for cross-references) for
     relocated text were left alone (conc-*), to avoid changing all xrefs.
     New sections added after the changes use the prefix "adv-*" in IDs.
-->
<chapter id="advanced">
<title>PHPlot Advanced Topics</title>
<abstract><title></title>
  <para>
This chapter documents advanced PHPlot programming topics, going beyond the
material in <xref linkend="concepts"/>.
  </para>
</abstract>

<sect1 id="adv-customclass">
<title>Custom PHPlot Class</title>
<abstract><title></title>
  <para>
This section describes how to create a custom PHPlot class.
  </para>
</abstract>
<para>
If you have a number of applications that use PHPlot, and you want to
standardize some of the PHPlot default settings, you can define your
own class which extends the PHPlot class and changes the default settings.
Here is a short example of a custom PHPlot class, which changes the
following defaults:
  <itemizedlist>
    <listitem>
      <para>Use a TrueType font for all text</para>
    </listitem>
    <listitem>
      <para>Change the default image size to 800 x 600</para>
    </listitem>
    <listitem>
      <para>Change the default title colors to red</para>
    </listitem>
  </itemizedlist>
</para>

<para>
To extend the PHPlot class, declare your class as shown below. Make sure
your class constructor calls the PHPlot class constructor before changing
any settings.
<programlisting><![CDATA[<?php
# Define a custom PHPlot class

// Load the PHPlot class first
require_once 'phplot.php';

// Define a class which extends PHPlot:
class my_phplot extends PHPlot {
  function __construct($width=800, $height=600, $out=NULL, $in=NULL)
  {
    parent::__construct($width, $height, $out, $in);
    $this->SetDefaultTTFont('LiberationSans-Bold'); // System dependent
    $this->SetTitleColor('red');
  }
}
]]></programlisting>
</para>

<para>
To use this custom PHPlot class, use <literal>require_once</literal> to
include the file containing the class definition, then create an instance
of the custom class.
<programlisting><![CDATA[$plot = new my_phplot();
]]></programlisting>
You can then use the <literal>$plot</literal> object exactly the same as
you might use any other PHPlot object.
</para>

</sect1>

<sect1 id="conc-truecolor">
<title>Truecolor Images</title>
<abstract><title></title>
  <para>
This section contains information about using
<link linkend="def-truecolor">Truecolor images</link> in PHPlot.
This material supplements the text in the <xref linkend="conc-colors"/>.
  </para>
</abstract>
<para>
Truecolor image support was added to PHPlot-5.1.1. With Truecolor image
support, you can:
  <itemizedlist>
    <listitem>
      <para>Create images with a larger number of colors</para>
    </listitem>
    <listitem>
      <para>Control color transparency with alpha blending</para>
    </listitem>
    <listitem>
      <para>Perform advanced image processing operations</para>
    </listitem>
  </itemizedlist>
</para>
<para>
An example of using Truecolor with PHPlot can be found in
<xref linkend="ex-truecolor-histogram"/>.
</para>

<sect2 id="conc-truecolor-overview">
<title>Using Truecolor Images in PHPlot</title>
<para>
To make a Truecolor image in PHPlot, create an object of the derived class
<literal>PHPlot_truecolor</literal> instead of the class
<literal>PHPlot</literal>.
For example, replace this:
<programlisting><![CDATA[$plot = new PHPlot(800, 600);
]]></programlisting>
with this:
<programlisting><![CDATA[$plot = new PHPlot_truecolor(800, 600);
]]></programlisting>
</para>

<para>
That is all you need to do in order to create truecolor images. All PHPlot
methods are compatible with PHPlot_truecolor objects. An image file
produced from a PHPlot_truecolor object with no other programming changes
will be the same as an image file produced from a PHPlot object except as
described under <xref linkend="conc-truecolor-fileformats"/>.
</para>

<para>
One of the advantages of truecolor images is the ability to use
variable transparency. This is described in the next two sections.
</para>

</sect2>

<sect2 id="conc-truecolor-alpha">
<title>Understanding Variable Transparency (Alpha)</title>
<para>
Colors in a truecolor image have four components: red, green, blue, and
alpha. The alpha component corresponds to the transparency of a color.
An alpha value of zero means the color is opaque, and an alpha value
of 127 means the color is transparent, or clear.<footnote>
  <para>
PHPlot follows the GD Library convention here. Other systems use alpha=0 to
mean transparent, and a maximum alpha value to mean opaque.
  </para></footnote>
In between values, from 1 to 126, correspond to various amounts of
transparency.
</para>

<para>
Transparency is only meaningful when drawing objects on top of objects, or
objects on top of the image background. An object drawn with an
opaque color (alpha=0) will replace whatever was in the image before the
object was drawn at that position. An object drawn with an transparent
color (alpha=127) is invisible and does not affect the appearance of the
image. An object drawn with a color that has an alpha value between 1 and
126 will be combined with whatever was in the image before the object was
drawn using alpha blending.
</para>

<para>
The PHP Manual explains alpha blending like this: "In blending mode, the
alpha channel component of the color supplied to all drawing functions
determines how much of the underlying color should be allowed to shine
through. As a result, gd automatically blends the existing color at that
point with the drawing color, and stores the result in the image. The
resulting pixel is opaque."<footnote><para>From the PHP Reference Manual,
imagealphablending</para></footnote>
</para>

<note>
  <para>
Note that the PHP Manual says the resulting pixel is opaque. This means
that objects drawn with alpha above 0 are partially or completely transparent
only relative to other objects in that same image. This does not result
in an image with transparent portions which would show through to a browser
or desktop background, for example.
(Read the PHP Manual page for <function>imagesavealpha</function> for more
about this behavior and how to change it.)
Use <xref linkend="SetTransparentColor"/> to make portions of an image
transparent to web page or desktop backgrounds.
  </para>
</note>

<para>
<?dbfo keep-together="always"?>
The following figure shows the effect of alpha blending when drawing lines.
The left side shows the normal overlaying of lines, and the right side
shows alpha-blended overlaying of lines with alpha = 60 (that is, 60/127
transparency).
The effect of alpha blending can be seen where the data lines cross.
Note: These plots use wide lines (3 pixels) and the portions of
the images are magnified 2x to show detail.
  <informalfigure>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/alpha-blending.png" scale="58" format="PNG" />
      </imageobject>
      <textobject>
        <phrase>Line intersections without and with alpha blending.</phrase>
      </textobject>
    </mediaobject>
  </informalfigure>
</para>

</sect2>

<sect2 id="conc-truecolor-using-alpha">
<title>Using Variable Transparency (Alpha) in PHPlot</title>
<para>
To use partially transparent colors (that is, colors with an alpha channel)
with a PHPlot_truecolor object, you can specify an alpha value as part of a
color specification, and you can specify a default alpha value for all data
colors.
</para>

<para>
Use of alpha values with a color specification is described below,
in <xref linkend="conc-truecolor-forms"/>.
Here are some examples of using colors with an alpha specification.
</para>

<para><?dbfo keep-together="always"?>
This sets the color used for labels to red=192, green=192, blue=33, and
alpha=50 (that is, 50/127 transparency).
<programlisting><![CDATA[$plot->SetTextColor(array(192, 192, 33, 50));
]]></programlisting>
</para>

<para><?dbfo keep-together="always"?>
This sets the color used for tick marks to the color 'blue' from the color
map, with alpha value 64 (64/127 transparency).
<programlisting><![CDATA[$plot->SetTickColor('blue:64');
]]></programlisting>
</para>

<para><?dbfo keep-together="always"?>
This sets colors for the first three data sets to red, green, and blue with
different alpha values. The three colors are represented using
different formats for illustration purposes.
<programlisting><![CDATA[$plot->SetDataColors(array(
      array(255, 0, 0, 60), // Red with alpha=60
      '#00ff0050',          // Green with alpha=80 (0x50)
      'blue:70'));          // Blue with alpha=70
]]></programlisting>
</para>

<para><?dbfo keep-together="always"?>
Instead of specifying the alpha value for each data set color, you can
provide a default alpha value for all data colors using the third argument to
This uses the colors specified in $my_color_array with a default alpha of
50. The default is applied to any color definition which does not already
have an alpha value.
<xref linkend="SetDataColors"/>.
<programlisting><![CDATA[$plot->SetDataColors($my_color_array, NULL, 50);
]]></programlisting>
</para>

<para><?dbfo keep-together="always"?>
This can also be used to apply an alpha value to the default data colors.
This retains the default data colors, but applies alpha = 50 (50/127
transparency) to all the colors. This is a quick way to get partially
transparent data colors without re-specifying all the colors.
<programlisting><![CDATA[$plot->SetDataColors(NULL, NULL, 50);
]]></programlisting>
</para>
</sect2>

<sect2 id="conc-truecolor-forms">
<title>Color Parameter Form Extensions</title>
<para>
In addition to the forms specified in <xref linkend="conc-colors-forms"/>,
colors specifications can include an alpha value. Although this works with
palette images as well as truecolor images, specifying alpha values
with palette images provides limited value.
<orderedlist>
  <listitem>
    <para>
A color name, as defined by <xref linkend="SetRGBArray" /> or from a built-in
color map if SetRGBArray was not called, followed by a colon and an alpha
value as a decimal number, for example: 'red:60'. The alpha value is
between 0 (opaque) and 127 (transparent).
Note that colors in the color map can be defined with or without an alpha
value. An alpha value appended to the color name overrides any specified
in the color map. For example, if the color 'red2' is defined in the color
map as array(255,0,0,80) - that is, red with 80/127 transparency - then
'red2' has alpha of 80, and 'red2:40' has alpha of 40.
    </para>
  </listitem>
  <listitem>
    <para>
Numeric color component values, in the form <literal>#rrggbbaa</literal>.
Here rr is red, gg is green, and bb is blue, and each component
value is represented as a 2-digit hexadecimal number between 00 and ff.
Also aa is alpha, represented as a 2 digit hexadecimal number between 00 and 7f.
For example, <literal>#00ff0010</literal> is green with 16/127 transparency.
    </para>
  </listitem>
  <listitem>
    <para>
A PHP array of red, green, blue, and alpha color component values.
Each value of red, green, and blue are in the range 0 to 255 inclusive,
and the alpha component is in the range 0 to 127 inclusive.
For example,
<literal>array(0,255,0,16)</literal> is the same green with 16/127 transparency.
    </para>
  </listitem>
</orderedlist>
</para>

</sect2>

<sect2 id="conc-truecolor-fileformats">
<title>Image Formats and File Formats, Palette and Truecolor</title>
<para>
PHPlot can produce JPEG, PNG, and GIF image files (and possibly others).
You select the PHPlot output image file format with
<xref linkend="SetFileFormat"/>.
</para>

<para>
PHPlot works with GD images before producing an image file. There are two
types of GD images: truecolor and palette. Truecolor images represent
pixels as 32 bit values, combining 8 bits each of red, green, and blue
components with a 7 bit alpha (transparency) value. Palette images use a
color table with at most 256 entries, and represent pixels as 8 bit indexes
into the color table. The palette image color table entries have 32 bit
values, with the same components as truecolor image pixel values. So
palette images in GD can have at most 256 unique colors, but there is no
limitation on the number of unique colors in truecolor images.
</para>

<para>
As long as you don't specify a background image when creating your plot object,
truecolor images are created with the <literal>PHPlot_truecolor</literal> class,
and palette images are created with the <literal>PHPlot</literal> class.
If you specify a background image, the GD image created by PHPlot matches the
type - truecolor or palette - of your background image file.
More on background image files can be found in
<xref linkend="conc-truecolor-background"/> below.
</para>

<para>
What happens when you output the GD image to an image file depends on the
image file format you select.
</para>

<para>
JPEG image files are always truecolor. Whether you have a GD palette image
or truecolor image, you will get a truecolor image file.  Note: You are
discouraged from using JPEG images with PHPlot, because they are not
optimal for this type of graphical information due to use of lossy
compression.
</para>

<para>
GIF image files are always palette type, limited to 256 colors. If
you have a GD palette image, you will get a palette GIF image file with the
colors you used in your plot. If you have a a GD truecolor image, GD will
convert your image to palette format, reducing the number of colors to 256
if necessary. This may change the appearance of your plot. Note that some
versions of the PHP manual for <function>imagecreatetruecolor()</function>
incorrectly state that you cannot output a GIF file from a truecolor GD image.
</para>

<para>
PNG image files support truecolor images and palette images of various
color depths.  If you have a GD palette image, you will get a palette PNG
image file. If you have a GD truecolor image, you will get a truecolor PNG
image file. Note that by default, even though PNG truecolor image files
support an alpha channel, GD eliminates the alpha channel when producing a
PNG file. The visual effects of alpha blending are reproduced using opaque
colors. GD apparently does this due to poor support in viewers for alpha
channels. Refer to the PHP Manual page on
<function>imagesavealpha()</function> for details.
</para>

<para>
The following figure shows the relationship between constructor, background
image format, GD image type, and image file format.
  <informalfigure>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/truecolor-formats.png" scale="62" format="PNG" />
      </imageobject>
      <textobject>
        <phrase>Constrictor, GD image type, and image file formats.</phrase>
      </textobject>
    </mediaobject>
  </informalfigure>
</para>

<para>
In the initial release of Truecolor support in PHPlot-5.1.1, alpha channel
information was ignored when using a PHPlot object, and only used with a
PHPlot_truecolor object. This was changed in PHPlot-5.1.2, and alpha
channel information is used for both PHPlot and PHPlot_truecolor classes.
However, alpha channel information is not always useful with palette
images.
More on this can be found in <xref linkend="conc-truecolor-palette"/> below.
</para>
</sect2>

<sect2 id="conc-truecolor-plottypes">
<title>Truecolor Images and Plot Types</title>
<para>
All PHPlot plot types work with truecolor images, but not all plot types
work well with alpha blending of data colors.
</para>

<para>
<variablelist>
  <varlistentry>
    <term>Pie Charts</term>
    <listitem>
      <para>
Avoid using alpha blending with pie charts. The underlying GD
routines do not fill the pie areas in a way that allows proper blending of
colors. Flat pie charts (using SetShading(0)) are not too bad, showing some
artifacts, but shaded or 3D-look pie charts are poorly rendered.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>Bar Charts</term>
    <term>Stacked Bar Charts</term>
    <listitem>
      <para>
Bars are drawn properly, but the 3D shading affects get blended, resulting
in less than ideal appearance. Flat, outlined bars (using SetShading(0))
are fine with transparency, but when shading is on the 3D shadows overlap
portions of the bars. With alpha blending, the overlaps take on new colors.
      </para>
    </listitem>
  </varlistentry>
</variablelist>
</para>

</sect2>

<sect2 id="conc-truecolor-background">
<title>Background Images</title>
<para><?dbfo keep-together="always"?>
When creating a PHPlot or PHPlot_truecolor object, you can provide an
existing image filename to the constructor as the fourth argument,
<parameter>$input_file</parameter>.
<programlisting><![CDATA[$plot = new PHPlot(800, 600, NULL, 'myimage.png');
]]></programlisting>
This image file becomes the background for your plot. (The function
<xref linkend="SetInputFile"/> also does this,
but is deprecated for use except through the constructor.)
</para>

<para>
If you provide an input file to the constructor, the image associated with
your PHPlot or PHPlot_truecolor object takes on the type of the input file:
palette or truecolor. It does not matter which constructor you use when
specifying an input file as background.
(This was changed after the initial release of truecolor support.
In PHPlot-5.1.1, you must use the PHPlot_truecolor constructor in order to
use some truecolor features even when you use a truecolor background
image file. Starting with PHPlot-5.1.2 you can use either constructor.)
</para>

<note>
  <para>
The above applies only when an input file is specified to the PHPlot
or PHPlot_truecolor constructor.  It does not apply to
an image background set with <xref linkend="SetBgImage"/>
nor to a plot area background set with <xref linkend="SetPlotAreaBgImage"/>.
  </para>
</note>

</sect2>

<sect2 id="conc-truecolor-callbacks">
<title>Additional Operations on Truecolor Images Using Callbacks</title>
<para>
Advanced operations on truecolor PHPlot images are possible using PHPlot
callbacks. See <xref linkend="callbacks"/> for more information about using
callbacks.  Here are some of the operations you can perform, and the
corresponding GD functions.  Refer to the GD section of the PHP Manual for
more information on these functions.
</para>
<note>
  <para>
Some of these functions are only available when PHP was built with the
bundled version of the GD library.
  </para>
</note>

<sect3 id="conc-truecolor-callbacks-antialias">
<title>imageantialias()</title>
<para><?dbfo keep-together="always"?>
You can turn on anti-aliasing of truecolor images. This must be done before
anything is drawn, so the pre-drawing callback <literal>draw_setup</literal>
is used. Here is a partial example:
<programlisting><![CDATA[function pre_plot($img)
{
    imageantialias($img, True);
}
...
$plot = new PHPlot_truecolor(1024, 768);
$plot->SetCallback('draw_setup', 'pre_plot');
]]></programlisting>
</para>

<para>
Note: There are limitations with anti-aliased images. You cannot use wide
lines (<xref linkend="SetLineWidths"/>).
Patterned lines do not work, so if you are displaying
X or Y grid lines you must use <xref linkend="SetDrawDashedGrid"/>(False)
to make these solid.
Also note that TrueType Font (TTF) text is always anti-aliased, even on
palette images, regardless of the use of <function>imageantialias()</function>.
</para>
</sect3>

<sect3 id="conc-truecolor-callbacks-alphablending">
<title>imagealphablending() and imagelayereffect()</title>
<para>
These functions control the combining of partially transparent colors. They
can be used via a <literal>draw_setup</literal> callback, in the same way
as <function>imageantialias</function> in the example above.
Note that alpha blending is on by default with all truecolor images.
</para>
</sect3>

<sect3 id="conc-truecolor-callbacks-gammacorrect">
<title>imagegammacorrect()</title>
<para><?dbfo keep-together="always"?>
You can have the GD library perform gamma adjustment on a truecolor image.
This must be done after all drawing, so the post-drawing callback
<literal>draw_all</literal> is used. Here is a partial example:
<programlisting><![CDATA[function post_plot($img)
{
    imagegammacorrect($img, 1.0, 0.5); // Input gamma=1, output gamma=.5
}

...
$plot = new PHPlot_truecolor(1024, 768);
$plot->SetCallback('draw_all', 'post_plot');
]]></programlisting>
</para>
</sect3>
</sect2>

<sect2 id="conc-truecolor-palette">
<title>Palette Images and Advanced Color Features</title>
<para>
You will have a GD palette image if you use the <literal>PHPlot</literal>
constructor without a background image file, or if you use either the
<literal>PHPlot</literal> or <literal>PHPlot_truecolor</literal>
constructors with a background image file that is a palette image (GIF or
some types of PNG). You can use alpha color specifications with palette GD
images, but this is not recommended. The results are not well documented,
but the following behavior has been observed:
</para>

<para>
  <itemizedlist>
    <listitem>
      <para>
There is no alpha blending. Drawing operations simply replace existing
pixels values with the new pixel values. (These are actually index values
into the color table.)
      </para>
    </listitem>

    <listitem>
      <para>
Alpha values are ignored when the image is output to a JPEG or GIF file.
All colors are output as opaque.
      </para>
    </listitem>

    <listitem>
      <para>
Alpha values are preserved in PNG image files. These will be palette, not
truecolor, PNG images, with the color table containing the alpha values.
You can therefore have palette PNG files with partial transparency, however
not all viewers properly support this.
      </para>
    </listitem>
  </itemizedlist>
</para>

<para>
Nothing described in <xref linkend="conc-truecolor-callbacks"/> works with
palette images, including gamma adjust and anti-aliasing (except that
TrueType Font text is always anti-aliased.)
</para>
</sect2>

</sect1>

<sect1 id="callbacks">
<title>Callbacks</title>
<abstract><title></title>
  <para>
This section documents the callback feature in PHPlot.
  </para>
</abstract>

<para>
Callbacks allow a programmer using PHPlot to insert their own functions
into the graph drawing process. Callbacks are currently also used for
development and testing of PHPlot.
</para>

<warning>
  <para>
All PHPlot class variables, and all methods/functions which are not
documented in the "Reference" section of the PHPlot Reference Manual, are
considered to be for internal use and are subject to be changed or removed
at any time.
If you call internal functions, or access internal class variables,
you greatly increase the risk of breaking your application with
future PHPlot releases.
  </para>
</warning>

<sect2 id="callbacks-api">
<title>Callbacks Application Interface</title>
<para>
Refer to these entries in the Function Reference:
  <itemizedlist>
    <listitem>
      <para>
<xref linkend="SetCallback"/> - Register a callback function
      </para>
    </listitem>
    <listitem>
      <para>
<xref linkend="GetCallback"/> - Return a currently registered callback function
      </para>
    </listitem>
    <listitem>
      <para>
<xref linkend="RemoveCallback"/> - Unregister a callback function
      </para>
    </listitem>
  </itemizedlist>
</para>

<para>
Either a function name or an object and method can be registered as
a callback with <xref linkend="SetCallback"/>.
For more information about using callbacks with objects and methods,
see the PHP manual under
<ulink url="http://www.php.net/manual/en/language.pseudo-types.php#language.types.callback">Types, Pseudo Types, Callback</ulink>
and the documentation for the PHP
<ulink url="http://www.php.net/manual/en/function.call-user-func.php ">call_user_func</ulink>
function.
Also refer to <xref linkend="callbacks-objects"/> later in this manual.
Whether calling a function or an object method as a callback,
the same calling sequence is used.
</para>
<para>
  <programlisting><![CDATA[function_name($img, $passthrough_arg, [other_args...])
]]></programlisting>
</para>
<para>
  <variablelist>
    <varlistentry>
      <term>$img</term>
      <listitem>
        <para>
The GD image resource for the plot image.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>$passthrough_arg</term>
      <listitem>
        <para>
The third argument supplied to SetCallback ($arg) when the callback is
established. This allows the programmer to pass information to the callback
without using global variables. This can be any PHP type including array.
To pass a reference, you should put it into an array and pass the array.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>other_args...</term>
      <listitem>
        <para>
Zero or more additional arguments supplied by PHPlot to callbacks of this
type. Refer to <xref linkend="callbacks-names"/> to see what callback
reasons supply extra arguments.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

<para><?dbfo keep-together="always"?>
For example, given this callback setup:
  <programlisting><![CDATA[$plot->SetCallback('draw_graph', 'my_drawing_callback', $myvar);
]]></programlisting>
Then PHPlot will call:
  <programlisting><![CDATA[my_drawing_callback($img, $myvar_value, $plot_area);
]]></programlisting>
Where $myvar_value is the value of $myvar at the time SetCallback was called.
(The plot_area parameter is only supplied for the draw_graph callback in
PHPlot-5.1.0 and later.)
</para>

<para>
Some callbacks are expected to return a value. This is documented in 
<xref linkend="callbacks-names"/>. In all other cases, the return value
from a callback function is ignored.
(Callbacks which return a value were implemented in PHPlot-5.1.3.)
</para>
</sect2>

<sect2 id="callbacks-access">
<title>Callback Function Access</title>
<para>
By default, the callback function has access only to the GD image resource
as the $img argument, the pass-through argument provided when the callback
function was registered, and additional arguments (if any) provided by
PHPlot for the callback. It does not have access to the PHPlot
class object instance, nor any of its contents.
</para>

<para>
If you need access to the internals of the PHPlot class instance from your
callback, you have three options.
  <orderedlist>
    <listitem>
      <para>
You can declare your PHPlot class instance variable as
<emphasis>global</emphasis>.
      </para>
    </listitem>
    <listitem>
      <para>
You can pass the instance variable as the $arg when registering the
callback. With PHP5, this will pass a reference to the object, which allows
reading and changing variables. (PHP4 would pass a copy of the object at the
time the callback function is being set up, which would probably not be
useful. There are work-arounds, but PHP4 is no longer supported.)
      </para>
    </listitem>
    <listitem>
      <para>
You can use a class method which extends PHPlot.
This is described in <xref linkend="callbacks-objects"/>.
      </para>
    </listitem>
  </orderedlist>
</para>

<para>
As stated in the warning at the top of this section, any access to the class
internals is risky and subject to break with any new update to PHPlot.
</para>

</sect2>


<sect2 id="callbacks-names">
<title>Available Callbacks</title>
<para>
This section defines the currently available callback names. A callback
name is also called a <emphasis>reason</emphasis>.
</para>

<para>
Most of the callbacks currently available are drawing callbacks, activated
during the graph drawing process started by <xref linkend="DrawGraph"/>.
By convention, a drawing callback occurs right after the event which it names.
For example, the <command>draw_titles</command> callback will be called after
drawing the plot titles.
</para>

<para>
Debug callbacks are for use when developing and debugging PHPlot itself.
Needless to say, their use for other purposes is discouraged.
</para>

<para>
The following table lists the available callback reasons.
</para>

<para>
  <informaltable id="callback-reasons">
    <tgroup cols="4">
      <?dbhtml table-summary="PHPlot available callback reasons"?>
      <colspec colname="c1" colwidth="26*" />
      <colspec colname="c2" colwidth="19*" />
      <colspec colname="c3" colwidth="19*" />
      <colspec colname="c4" colwidth="40*" />
      <thead>
        <row>
          <entry>Callback Name:</entry>
          <entry>Calling Point:</entry>
          <entry>Extra Parameters:</entry>
          <entry>Notes:</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>data_color</entry>
          <entry>Every time a color is needed for a data element.</entry>
          <entry>$row, $col, $extra</entry>
          <entry>The callback is expected to return an integer color index
             into the data colors array. This is for custom color selection.
             For more information, see
             <xref linkend="conc-colors-datacolor-callback"/>.</entry>
        </row>
        <row>
          <entry>draw_setup</entry>
          <entry>After all setup, before drawing anything.</entry>
          <entry>(None)</entry>
          <entry>Anything drawn here will be covered by the background.</entry>
        </row>
        <row>
          <entry>draw_image_background</entry>
          <entry>After drawing the image backgrounds and border.</entry>
          <entry>(None)</entry>
          <entry></entry>
        </row>
        <row>
          <entry>draw_plotarea_background</entry>
          <entry>After drawing the plot area background.</entry>
          <entry>plot_area</entry>
          <entry>plot_area parameter was added in PHPlot-5.1.0</entry>
        </row>
        <row>
          <entry>draw_titles</entry>
          <entry>After drawing the plot title, X and Y titles.</entry>
          <entry>(None)</entry>
          <entry>Called even if no titles were set.</entry>
        </row>
        <row>
          <entry>draw_axes</entry>
          <entry>After drawing the X and Y axis and grid lines.</entry>
          <entry>(None)</entry>
          <entry>Not called for pie charts.</entry>
        </row>
        <row>
          <entry>draw_graph</entry>
          <entry>After drawing the body of the graph.</entry>
          <entry>plot_area</entry>
          <entry>plot_area parameter was added in PHPlot-5.1.0</entry>
        </row>
        <row>
          <entry>draw_border</entry>
          <entry>After drawing the plot area border.</entry>
          <entry>(None)</entry>
          <entry>Not called for pie charts before PHPlot-5.6.0</entry>
        </row>
        <row>
          <entry>draw_legend</entry>
          <entry>After drawing the legend, if legend is enabled.</entry>
          <entry>(None)</entry>
          <entry>Not called if no legend was set.</entry>
        </row>
        <row>
          <entry>draw_all</entry>
          <entry>After all drawing is complete.</entry>
          <entry>plot_area</entry>
          <entry>Added in PHPlot-5.1.0</entry>
        </row>
        <row>
          <entry>debug_textbox</entry>
          <entry>Just before drawing any text.</entry>
          <entry>$px, $py, $bbox_width, $bbox_height</entry>
          <entry>Provides access to the orthogonal bounding box position
              and size for the text string.</entry>
        </row>
        <row>
          <entry>debug_scale</entry>
          <entry>Called at end of many scale calculation functions.</entry>
          <entry>Function name, then an array of variable name =&gt; value</entry>
          <entry>For displaying intermediate values in margin and scale
              calculations.</entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
</para>
<note>
  <title>Notes:</title>
  <para>
Several of the drawing callbacks include <parameter>plot_area</parameter>
as an extra parameter. This is an array of 4 values that define the plot area
within the image, in GD pixel coordinates, as left_x, top_y, right_x, and
bottom_y. For more information, see <xref linkend="dev-layout" />.
  </para>
  <para>
See <xref linkend="callbacks-drawing"/>
for information on using the drawing callbacks to annotate your plot.
  </para>
</note>

</sect2>

<sect2 id="callbacks-objects">
<title>Object Methods as Callbacks</title>
<para>
The callback function argument to <xref linkend="SetCallback"/>
can be an array of two elements: a class variable and a method.
This can be used with any class, but here we are interested in using an
extension of the PHPlot class.
Consider the following setup:
</para>
<para>
  <programlisting><![CDATA[class my_PHPlot extends PHPlot
{
  function my_PHPlot($width=600, $height=400, $outfile=NULL, $infile=NULL)
  {
    $this->PHPlot($width, $height, $outfile, $infile);
  }

  function callback($img, $arg)
  {
    fwrite(STDERR, "callback in object\n");
    fwrite(STDERR, "Plot area: ({$this->plot_area[0]}, {$this->plot_area[1]}) :");
    fwrite(STDERR, " ({$this->plot_area[2]}, {$this->plot_area[2]})\n");
  }
}
]]></programlisting>
</para>

<para>
We define a class which extends PHPlot, and a method 'callback' which
displays the plot area using the internal PHPlot class variable plot_area.
(Note we are using a PHP4-style constructor, which also works with PHP5.
You can use the PHP5 constructor method instead.)
</para>

<para>
We will then create an instance of the extended class, and set a callback.
  <programlisting><![CDATA[$plot = new my_PHPlot(400,300);
$plot->SetCallback('draw_titles', array($plot, 'callback'));
]]></programlisting>
This is for PHP5. For PHP4, you need to use a reference to the $plot instance.
Note that PHP4 is no longer supported.
</para>

<para>
When the draw_titles callback is triggered, it will call the 'callback'
method inside our extended class. Because this is an extension of the
PHPlot class, it has access to all the member variables via $this.
</para>

</sect2>

<sect2 id="callbacks-drawing">
<title>Using Callbacks to Annotate Plots</title>
<para>
This section contains information about using PHPlot callbacks to annotate
a plot with text and graphics. This is an advanced topic, and requires some
knowledge of both PHPlot and the PHP GD extension.
</para>
<warning>
  <para>
The information in this section uses features which are recent additions
to PHPlot, and in some cases uses PHPlot internal variables and functions.
As a result, these methods are less likely to work with older releases, and
more at risk to change or break in future releases.
  </para>
</warning>

<para>
This section will first provide general information and advice about
annotating plots using callbacks.
<!-- Note exception, link to example's section not example. -->
After, portions of the script from <xref linkend="ex-annotate" />
will be explained in more detail.
</para>

<para>
The emphasis here is on using callbacks, but annotation is also possible 
without callbacks.
You can use <xref linkend="SetPrintImage"/>(False) to disable automatic
output of your image. Then, when <xref linkend="DrawGraph"/> returns, you
can annotate your plot using GD functions on the <literal>img</literal>
member variable of your PHPlot object. Use of callbacks is preferred,
however, because it makes your script somewhat less dependent on PHPlot
internals (such as the <literal>img</literal> variable).
</para>

<sect3 id="callbacks-drawing-set">
<title>Setting the callback</title>
<para>
Use <xref linkend="SetCallback"/> to establish a drawing callback.
You can find a list of callbacks in <xref linkend="callbacks-names"/>.
The various callbacks with names starting 'draw_' are called at different
points in the drawing process. Drawn objects will cover items drawn at an
earlier stage. For example, if you draw a line from a 'draw_titles' callback
(which is called after the plot titles are drawn, but before the graph is
drawn), the line would be 'behind' and possibly covered by the plotted data.
</para>
<para>
Note that PHPlot does very little except save parameter values until you
call <xref linkend="DrawGraph"/>. For that reason, you should use GD functions
for annotation only from a drawing callback (that is, a callback with a name
starting with 'draw_').
The drawing callbacks are called after PHPlot calculations and image resource
setup, at which point everything is ready for drawing.
In addition, you should not use PHPlot functions which control plot
appearance from your drawing callback. These would either have no affect,
because it is too late, or produce unexpected results.
</para>
</sect3>

<sect3 id="callbacks-drawing-coords">
<title>Coordinates</title>
<para>
When drawing with GD, you will use the <link linkend="def-devcoor">Device
Coordinate system</link>. The coordinates in this system are pixels, with
the origin in the upper left corner of your image. Y advances down and X
advances to the right.
</para>
<para>
If you want to make annotations relative to specific values in your plot data,
you need to translate those values from
<link linkend="def-worldcoor">World Coordinates</link> to device coordinates.
Use the PHPlot function <xref linkend="GetDeviceXY"/>
to perform this translation.
You will need access to your PHPlot object from inside your callback function
in order to use this (or any other PHPlot method function). You can make it
global, or designate it as the passthrough argument to SetCallback.
  <note>
    <para>
This does not apply to pie charts, which have do not use world coordinates.
    </para>
  </note>
</para>
<para>
If your annotations will fall outside the plot area (for example, in an
area you reserved for annotation using <xref linkend="SetPlotAreaPixels"/>
or <xref linkend="SetMarginsPixels"/>, then you need not be concerned with
coordinate translation. Of course, you can also add annotations at fixed
pixel coordinates inside the plot area, however these may overlay (if done
from a draw_graph or later callback) or underlay (if done before the
draw_graph callback) the plotted data.
</para>
</sect3>

<sect3 id="callbacks-drawing-colors">
<title>Colors</title>
<para>
Every GD drawing function you use will require a color value argument.
You are recommended to allocate your own colors in your callback using the
GD function <function>imagecolorresolve()</function>. This function
will always return a color index, by either re-using an existing color in
the image's color map, or by allocating a new color.
Using imagecolorresolve() rather than trying to access the PHPlot internal
variables for color indexes will protect your script from breaking if the
way PHPlot manages its internal colors ever changes.
</para>
</sect3>

<sect3 id="callbacks-drawing-text">
<title>Text</title>
<para>
Text can be added to your plot using GD functions which include
<function>imagestring</function>, for build-in simple fonts, and
<function>imagettftext</function> for TrueType font text. To use these
functions, you need device coordinates, as described above.
</para>
<para>
You can also add text to your plot using the PHPlot function
<function>DrawText</function>. This is documented only for internal
use by PHPlot, so there is a risk of future incompatibility. But this
function provides support for controlling the text justification, and works
better with multi-line text.
</para>
</sect3>

<sect3 id="callbacks-drawing-example">
<title>Example</title>
<para>
This example creates a bar chart and adds annotation. The goal is to draw an
ellipse and add text to the highest and lowest bars in a bar chart.
<!-- Note exception, link to example's section not example. -->
Refer to <xref linkend="ex-annotate" /> for the complete script and
output from this example.
</para>

<para>
The script starts with the usual PHPlot object creation and setup.
<programlisting><![CDATA[$plot = new PHPlot(800, 600);
$plot->SetTitle('Monthly Widget Sales');
...
]]></programlisting>
(For the complete script, see the example referenced above.)
</para>

<para>
Before calling DrawGraph, establish the drawing callback. This uses the
<literal>draw_all</literal> callback, which gets called when all drawing is
complete in DrawGraph. (Note: If using PHPlot-5.0.7 or earlier, use
'draw_graph' instead, as 'draw_all' was not yet available.)
The name of our callback function is <literal>annotate_plot</literal>,
and we are passing the PHPlot object ($plot) as a pass-through parameter.
You can use a global or class callback instead -
see <xref linkend="callbacks-api"/> for more on these options.
<programlisting><![CDATA[$plot->SetCallback('draw_all', 'annotate_plot', $plot);
]]></programlisting>
</para>

<para>
Here is the declaration of our callback function. The <literal>$img</literal>
parameter is provided by PHPlot itself, and is the GD resource for our image.
The <literal>$plot</literal> parameter is the pass-through argument we provided
above when establishing the callback.
Some callbacks make other parameters available. In fact, 'draw_all' provides
the plot area coordinates as an additional parameter, but we don't need that
here so we do not have to include that in the function declaration.
<programlisting><![CDATA[function annotate_plot($img, $plot)
{
]]></programlisting>
</para>

<para>
As stated above, you should allocate your own colors, rather than trying to
get into PHPlot's internals for color values. Here we allocate two colors
and assign the color indexes to local variables:
<programlisting><![CDATA[$red = imagecolorresolve($img, 255, 0, 0);
$green = imagecolorresolve($img, 0, 216, 0);
]]></programlisting>
</para>

<para>
Next, we want to draw graphics centered on two points in our data. The
points were calculated as best_index (X), best_sales (Y), worst_index (X),
and worst_sales (Y). In order to draw at these locations, we need to
translate the values from
<link linkend="def-worldcoor">World Coordinates</link> to
<link linkend="def-devcoor">Device Coordinates</link>.
This is done using the PHPlot function <xref linkend="GetDeviceXY"/>.
<programlisting><![CDATA[list($best_x, $best_y) = $plot->GetDeviceXY($best_index, $best_sales);
list($worst_x, $worst_y) = $plot->GetDeviceXY($worst_index, $worst_sales);
]]></programlisting>
</para>

<para>
Now we are ready to draw some ellipses, centered on our two data points.
The values 50 and 20 are the width and height, in pixels.
<programlisting><![CDATA[imageellipse($img, $best_x, $best_y, 50, 20, $green);
imageellipse($img, $worst_x, $worst_y, 50, 20, $red);
]]></programlisting>
</para>

<para>
As stated above, we have two options for text, and the example uses each method.
We can draw text using the GD functions, but we have to do a little more
work to position the text. Here the text is approximately centered
horizontally and above the data point. (Note ImageString by default uses the
upper left corner of the text string for positioning.)
<programlisting><![CDATA[$font = '3';
$fh = imagefontheight($font);
$fw = imagefontwidth($font);
imagestring($img, $font, $best_x-$fw*4, $best_y-$fh-10, 'Good Job!', $green);
]]></programlisting>
</para>

<para>
Or, we can use the PHPlot internal function DrawText. With a PHPlot version
5.1.0 and later, we omit the font specification and it will default to the
generic font, which can be set with <xref linkend="SetFont"/>('generic', ...)
<programlisting><![CDATA[$plot->DrawText('', 0, $worst_x, $worst_y-10, $red, 'Bad News!', 'center', 'bottom');
]]></programlisting>
</para>

</sect3>

</sect2>

</sect1> <!-- callbacks -->

<sect1 id="conc-colors-datacolor-callback">
<title>Custom Data Color Selection</title>
<abstract><title></title>
  <para>
This section describes customizing the selection of data colors using a
PHPlot callback. The data color callback was added in PHPlot-5.1.3.
  </para>
</abstract>

<sect2 id="conc-colors-datacolor-callback-standard">
<title>Standard Behavior of Data Color Selection</title>
<para>
Before explaining how to customize data color selection, here is a review
of how data color selection works by default.
</para>

<para>
Think of your data array as having rows and columns. The rows represent
values of the independent variable (usually X), and the columns contain one
or more values of the dependent variable (usually Y) for that value of the
independent variable. For this discussion, ignore any additional entries in
the data array, such as labels and X values.
The set of values from a column in your data array is also referred to as a
data set.
</para>

<para>
The standard behavior of PHPlot is to select a data color from the data
colors array using the column index for the data point. The selected color
will be used to draw a point marker, line segment, bar, etc.
This was explained in <xref linkend="conc-colors-datacolors"/>.
</para>

<para>
For example, if you have a data array with 12 rows and 3 columns for a bar
chart, you are drawing 12 groups of 3 bars. Within each bar group, the first
bar will be drawn with the first color in the data colors array (the color
with index 0), the second bar will use the second color from
the data colors array, and the third bar will use the third color.
You can see this in <xref linkend="example-bars1"/>, where the first three
colors in the data colors array are SkyBlue, green, and orange.
</para>

<para>
There are two other color arrays: the error bar colors and data border
colors. Error bar colors are used in error plots to indicate the positive
and negative error range, and data border colors are used to outline bars
in bar charts when 3D shading is off.
The same index (but not necessarily the same color) is used to
select the color for any of the three elements which are used in a plot.
For example, the first data set in a points plot with error bars will use
data color index 0 for the point markers, and error bar color index 0 for
the error bars. The second bar in each group in an unshaded bar chart will
use the second data color to fill the bar and the second data border color
to outline it.
</para>

<para>
You can set the colors in the three color arrays with
<xref linkend="SetDataColors"/>, <xref linkend="SetErrorBarColors"/>, and
<xref linkend="SetDataBorderColors"/>.
PHPlot will pad all these arrays to the number of columns in your data
array, by duplicating the earlier values. (For example, if you have 5 data
sets and define 3 colors red, green, and blue, PHPlot will pad this to be a 5
color array red, green, blue, red, green.)
It will not truncate the arrays. This means you can define more data
colors than there are data columns. These additional colors will not be
used with the standard color selection method, but can be used with custom
data color selection.
</para>
</sect2>

<sect2 id="conc-colors-datacolor-callback-custom">
<title>Custom Data Color Selection</title>
<para>
If you need more control over data colors, you can use the PHPlot
callback called <literal>data_color</literal>.
(See <xref linkend="callbacks"/> for general information about callbacks.)
Some of the things you can do with custom data color selection are:
  <itemizedlist>
    <listitem>
      <para>
A bar chart with each bar having a different color.
      </para>
    </listitem>
    <listitem>
      <para>
A linepoints plot with different colors for the line segments and the
point markers.
      </para>
    </listitem>
    <listitem>
      <para>
A bar chart where the bar color depends on the value of that data point.
      </para>
    </listitem>
  </itemizedlist>
</para>

<note>
  <para>
Custom data color selection is not available for plot types
<literal>pie</literal>, <literal>area</literal>, or
<literal>stackedarea</literal>.
These three plot types already provide full control over the data color
selection, with no need for the callback function,
because each color in the color array is only used once.
  </para>
</note>

<para>
To customize the use of data colors, you will define a function that
accepts as arguments the data array row and column index numbers (0-based
integers), and returns the color array index.  Register this function with
PHPlot as a callback, and your function will be called whenever PHPlot
needs to select a data color.
</para>

<para>
Note that your callback will return an array index, not a color value.
For example, if it returns 0, the first color in the data colors array will
be used, and the first color in the error bar colors array (if error bars
are being drawn), and the first color in the data border colors array (if
data borders are being drawn).
You will most likely need to set up the data colors array (and possibly the
error bar colors array and data border colors array too) in order to get
the results you want.
</para>

<para>
A function to act as a data color callback might look like this:
<programlisting><![CDATA[function pickcolor($img, $passthrough, $row, $col, $extra = 0)
{
  $color_index = ...;

  return $color_index;
}
]]></programlisting>
The first two arguments are common to all callbacks: the PHPlot image
resource, and your passthrough argument (if any - see below).
(You generally will not need to access the image resource from the data colors
callback, but it is provided to all callbacks.)
The second and third arguments specify which data value is being plotted.
The $row corresponds to the independent variable (usually X), and
$col corresponds to the data set - plot line, bar within a bar group, etc.
Both $row and $col are zero based integers indexes.
</para>

<para>
Your callback is expected to return a color array index for this data
point. This will be an integer greater than or equal to zero, where zero
indicates the first color in the colors array should be used.
Your returned index should be within the bounds of the color array being
referenced, however PHPlot will use the value you return modulo the size of
the array. For example, the default PHPlot data colors array has 16 colors.
If your callback returns the value 20, the 5th color in the array will be
used (because 20 % 16 = 4, and index 4 is the 5th value in the array).
</para>

<para>
The $extra argument to your callback is for extra information you may need
to determine the color to use. Currently, this is only used for
'linepoints' plots and 'linepoints' error plots. These plots are drawn in
two stages: points and lines. In case you want different colors for the
points and lines, use the $extra argument. It will have the value 1 when
PHPlot is requesting the color of the point marker (shape), and the value
will be 0 when requesting the color of the line segment.
Note that the error bars of a linepoints error plot are drawn with the
color index returned for the points (but using the error bars colors, not
the data colors).
</para>

<para>
You do not need to specify the $extra argument in your callback function
declaration if you do not need it. But if you do specify it, you must make
it an optional argument with the value zero, because PHPlot does not always
supply the value.
</para>

<para>
The above function would be established as a data color callback for a
PHPlot object $plot like this:
<programlisting><![CDATA[$plot->SetCallback('data_color', 'pickcolor', $passthru_arg);
]]></programlisting>
The first argument is the callback name, or 'reason':
<literal>data_color</literal>.
The second argument is the name of your callback function. An object and
method can be used here instead - see <xref linkend="callbacks-objects"/>.
The third argument is an optional pass-through value that will be sent to
your callback function each time it is called.
</para>
</sect2>

<sect2 id="conc-colors-datacolor-callback-legend">
<title>Custom Data Color Selection and Legend</title>
<para>
If your plot includes a <link linkend="conc-legend">legend</link>,
the legend uses the colors in the order defined in the data colors array,
without regard to any custom data color selection callback.
When using a legend with a custom data color selection callback, you need
to define your data colors array (with <xref linkend="SetDataColors"/>, if
used) and set your legend lines (with <xref linkend="SetLegend"/>)
knowing that each legend line will reference the corresponding color in the
data array in order.
The Custom Bar Colors example referenced below demonstrates this.
</para>
</sect2>

<sect2 id="conc-colors-datacolor-callback-examples">
<title>Custom Data Color Selection Examples</title>
<para>
For examples of using a data color callback, see
<xref linkend="ex-colorcallbackgradient"/> and
<xref linkend="ex-colorcallbackbars"/>.
</para>

</sect2>
</sect1> <!-- Custom data colors -->

<sect1 id="conc-tuning">
<title>Tuning Parameters</title>
<abstract><title></title>
  <para>
This section documents some PHPlot class member variables that can be used
to adjust the appearance of plots.
You should rarely find it necessary to change these, and PHPlot does not
provide "Set" functions for them.
  </para>
</abstract>

<para>
The class member variables listed in <xref linkend="dev-vars-list"/> are
generally reserved for use only by the class implementation itself. But
there are some adjustments you can make to the appearance of a plot only
by changing member variables.
This section documents some PHPlot class member variables that alter a plot
appearance, but which do not have any defined class functions for you to
use to set the values.
</para>
<para>
For example, if you want PHPlot to draw the X/Y grid above (after) the plot,
rather than behind it, you would do the following:
  <programlisting><![CDATA[$plot = new PHPlot(800, 600);
...
$plot->grid_at_foreground = TRUE; // Draw grid after plot
]]></programlisting>
</para>

<sect2 id="conc-tuning-bars">
<title>Tuning Bar Charts</title>
<para>
These variables affect plot types <link linkend="plottype-bars">bars</link>
and <link linkend="plottype-stackedbars">stackedbars</link>.
They are used to control the width of the bars.
(For horizontal plots, the "width" of the bars is actually the height.)
</para>

<para>
  <variablelist>
    <varlistentry>
      <term><varname>bar_extra_space</varname></term>
      <listitem>
        <para>
Controls the amount of extra space within each group of bars. Default is 0.5,
meaning 1/2 of the width of one bar is left as a gap, within the space
allocated to the group (see <varname>group_frac_width</varname>).
Increasing this makes each group of bars shrink together.
Decreasing this makes the group of bars expand within the allocated space.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>group_frac_width</varname></term>
      <listitem>
        <para>
Controls the amount of available space used by each bar group. Default is 0.7,
meaning the group of bars fills 70% of the available space (but that includes
the empty space due to <varname>bar_extra_space</varname>).
Increasing this makes the group of bars wider.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>bar_width_adjust</varname></term>
      <listitem>
        <para>
Controls the width of each bar. Default is 1.0.
Decreasing this makes individual bars narrower, leaving gaps between the
bars in a group. This must be greater than 0. If it is greater than 1, the
bars will overlap.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
If bar_extra_space=0, group_frac_width=1, and bar_width_adjust=1
then all the bars touch (within each group, and adjacent groups).
</para>

</sect2>

<sect2 id="conc-tuning-bubbles">
<title>Tuning Bubble Plots</title>
<para>
These two variables set the range of bubble size in
<link linkend="plottype-bubbles">bubbles</link> plots.
</para>

<para>
  <variablelist>
    <varlistentry>
      <term><varname>bubbles_min_size</varname></term>
      <listitem>
        <para>
Minimum bubble diameter in pixels.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>bubbles_max_size</varname></term>
      <listitem>
        <para>
Maximum bubble diameter in pixels.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

<para>
The point with the smallest Z value will be drawn as a bubble with a diameter
of bubbles_min_size, and the point with the largest Z value will be drawn as
a bubble with a diameter of bubbles_max_size. That is, PHPlot linearly maps
the range of Z values in the plot to the range of bubble sizes.
</para>

<para>
By default, the minimum bubble size is 6 pixels, and the maximum bubble
size is 1/12 times the smaller of the plot area width and plot area height.
For example, if the plot area is 800x600, the default maximum bubble size
will be 50 pixels (600 / 12).
</para>

</sect2>

<sect2 id="conc-tuning-ohlc">
<title>Tuning OHLC Charts</title>
<para>
These variables affect plot types <link linkend="plottype-ohlc">ohlc</link>,
<link linkend="plottype-candlesticks">candlesticks</link>,
and <link linkend="plottype-candlesticks2">candlesticks2</link>,
For candlesticks plots, they adjust the calculation of the width of the
candlestick body.
For basic OHLC plots, they adjust the calculation of the length of the tick
marks which represent opening and closing prices.
(All of these were added in PHPlot-5.3.0.)
</para>
<para>
  <variablelist>
    <varlistentry>
      <term><varname>ohlc_max_width</varname></term>
      <listitem>
        <para>
This is one half the maximum width of the candlestick body, or
the maximum length of an OHLC tick mark. The default is 8 pixels.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>ohlc_min_width</varname></term>
      <listitem>
        <para>
This is one half the minimum width of the candlestick body, or
the minimum length of an OHLC tick mark. The default is 2 pixels.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>ohlc_frac_width</varname></term>
      <listitem>
        <para>
This is the fractional amount of the available space (plot width area
divided by number of points) to use for half the width of the candlestick
bodies or OHLC tick marks. The default is 0.3. This needs to be less than
0.5 or there will be overlap between adjacent candlesticks.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

<para>
PHPlot calculates a value to use for one half the width of the candlestick
bodies, or for the OHLC open/close tick mark lengths, as follows:
<programlisting>half_width = max(ohlc_min_width, min(ohlc_max_width, ohlc_frac_width * avail_area)
Where avail_area = plot_area_width / number_data_points
</programlisting>
</para>
</sect2>

<sect2 id="conc-tuning-pie">
<title>Tuning Pie Charts</title>
<para>
These variables adjusts the appearance of
<link linkend="plottype-pie">pie charts</link>.
</para>

<para>
  <variablelist>
    <varlistentry>
      <term><varname>pie_diam_factor</varname></term>
      <listitem>
        <para>
Diameter factor for shaded pie charts. This is the ratio of the height to
the width of the pie. The default value is 0.5, meaning the pie chart will be
drawn as an ellipse with height equal to half of its width.
This variable is ignored for unshaded plots (see <xref linkend="SetShading"/>),
which are always circular (diameter factor of 1.0).
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><varname>pie_min_size_factor</varname></term>
      <listitem>
        <para>
The minimum size of the pie in a pie chart, relative to the plot area size.
When pie chart autosizing is on (see <xref linkend="SetPieAutoSize"/>),
and pie labels are located outside the pie chart (as they are by default),
PHPlot will shrink the pie so the labels will fit inside the plot area.
To prevent an overly long label from making the pie too small,
PHPlot uses <varname>pie_min_size_factor</varname> to limit
how small the pie will become.
The default value is 0.5, meaning the pie chart will be no smaller than
half the width or height of the plot area, even if that makes the labels
fall partly off the image.
        </para>
        <para>
Setting this smaller allows the pie to be a smaller portion of the plot
area, if long labels require the space. Setting this larger prevents the
pie from becoming smaller in that case.
Setting this to 1.0 is approximately equivalent to using
<literal>SetPieAutoSize(False)</literal>. (The difference is that the
later still leaves a small gap between the pie and the plot area boundary.)
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

</sect2>

<sect2 id="conc-tuning-legend">
<title>Tuning the Legend</title>
<para>
This variable adjusts the appearance of the legend.
</para>
<para>
  <variablelist>
    <varlistentry>
      <term><varname>legend_colorbox_width</varname></term>
      <listitem>
        <para>
This is an adjustment factor for the width of the color boxes in the legend.
With the default value 1.0, the color boxes are as wide as one character in
the font used in the legend (width of "E" for TrueType fonts).
A value of 2.0 makes the color boxes twice as wide, and 0.5 makes them half
the character width.
(This was added in PHPlot-5.3.0.)
        </para>
        <para>
If point shapes are used in the legend instead of color boxes
(see <xref linkend="SetLegendUseShapes"/>),
then <literal>legend_colorbox_width</literal> still adjusts the horizontal
space allocated for the point shape. The point shape itself is not scaled,
but is always drawn at the same size as in the plot itself. If the plot
area has a color background, the width adjustment will stretch the
box in that color which is drawn behind the point shape.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>
</sect2>

<sect2 id="conc-tuning-labels">
<title>Label Tuning</title>
<para>
These variables affect the display of labels.
</para>

<para>
  <variablelist>
    <varlistentry>
      <term><varname>data_value_label_angle</varname></term>
      <listitem>
        <para>
This sets the angle, in degrees, for the position of data value labels near
the data points they label.
Together with <varname>data_value_label_distance</varname>,
it determines the position of the reference point for the label.
(This does not apply to data value labels for bars or stackedbars plots, as
the label position is fixed for these plot types.)
The default if unset is 90 degrees, which places the label above the data point.
PHPlot automatically selects which text alignment to use, based on the angle.
For example, with the default 90 degree angle, the label will
be horizontally centered, vertically bottom aligned.  If the angle is 0
degrees, the alignment is horizontally left, vertically centered.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>data_value_label_distance</varname></term>
      <listitem>
        <para>
This sets the distance, in pixels, for the position of data value labels near
the data points they label.
Together with <varname>data_value_label_angle</varname>,
it determines the position of the reference point for the label.
(This does not apply to data value labels for bars or stackedbars plots, as
the label position is fixed for these plot types.)
The default if unset is 5 pixels.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

</sect2>

<sect2 id="conc-tuning-misc">
<title>Miscellaneous Tuning</title>
<para>
These variables affect other aspects of the appearance of a plot.
</para>

<para>
  <variablelist>
    <varlistentry>
      <term><varname>grid_at_foreground</varname></term>
      <listitem>
        <para>
Controls the order in which certain plot elements are drawn. The default is
FALSE, meaning the X axis, Y axis, and grid lines are drawn before the main
part of the plot. If TRUE, the X axis, Y axis, and grid lines are drawn
after the main part of the plot, which results in the grid lines overlaying
the plotted data.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>locale_override</varname></term>
      <listitem>
        <para>
Set this to TRUE (or any non-empty value) to prevent PHPlot from loading
information about the locale from the operating system.
You must do this if you want to override the locale using
<function>setlocale()</function> from your PHP code, perhaps because your
platform does not allow setting the locale from environment variables.
See <xref linkend="SetNumberFormat"/> for more information.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><varname>safe_margin</varname></term>
      <listitem>
        <para>
This is the amount of space that PHPlot leaves between elements that
should not touch. The default is 5 pixels. Changing this is not recommended.
The effect is similar to changing the cellpadding on an HTML table.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</para>

</sect2>

</sect1> <!-- Tuning -->

<sect1 id="adv-multiplot">
<title>Multiple Plots Per Image</title>
<abstract><title></title>
  <para>
This section contains information about producing more than one plot on an
image.
  </para>
</abstract>

<para>
Using PHPlot, you can produce more than one plot on a single image.  These can
be <emphasis>tiled plots</emphasis> - separate plots manually positioned within
the image, or <emphasis>overlay plots</emphasis>.
Tiled plots are used when you want to display more than one plot on a single
image, for example side-by-side.
Overlay plots are used when you want to show more than one type or range
of data representation on a single plot.  For example, an overlay plot could
be used to show two data sets with different Y scales, or to overlay a bar
chart with a line plot.
You can also combine tiled and overlay plots in a single image.
</para>

<para>
An example of two tiled plots on an image can be found in
<xref linkend="ex-twoplot1"/>.
An example of an overlay plot can be found in
<xref linkend="ex-outbreak"/>
</para>

<sect2 id="adv-multiplot-overview">
<title>Overview of Multiple Plots</title>

<para>
When producing multiple plots on an image, a single PHPlot object is used.
The overall steps to be followed are:
  <orderedlist>
    <listitem>
      <para>
Create a <function>PHPlot</function> or <function>PHPlot_truecolor</function>
object (referred to here as <literal>$plot</literal>).
      </para>
    </listitem>
    <listitem>
      <para>
Use <literal>$plot->SetPrintImage(False)</literal> to disable automatic
output of the image after a plot is created.
      </para>
    </listitem>
    <listitem>
      <para>
Prepare the first plot, including setting the data array, plot type, and any
other applicable settings.
      </para>
    </listitem>
    <listitem>
      <para>
Use <literal>$plot->DrawGraph()</literal> when complete. 
This creates the plot, but does not produce any output.
      </para>
    </listitem>
    <listitem>
      <para>
Repeat the previous two steps to prepare each additional plot, completing
it with <literal>$plot->DrawGraph()</literal>.
      </para>
    </listitem>
    <listitem>
      <para>
When all the plots are complete, use <literal>$plot->PrintImage()</literal> to
output the completed image.
      </para>
    </listitem>
  </orderedlist>
</para>

<para>
The sections which follow contain additional information you will need
to produce multiple plots on a single image.
</para>
</sect2>

<sect2 id="adv-multiplot-settings">
<title>Plot Settings with Multiple Plots</title>

<para>
In general, PHPlot applies settings made for one plot as defaults for the
next plot, when using the same PHPlot class instance.
There are some special cases, however, which are discussed in the
sections below.
</para>

<sect3 id="adv-multiplot-global">
<title>Global Settings</title>
<para>
Certain plot elements apply to the image as a whole, not to individual plots.
PHPlot will draw these at most once per image. (That is, the element will be
drawn only the first time <literal>DrawGraph()</literal> is called after the
element has been set up.)
<itemizedlist>
  <listitem>
    <para>
Main title (<xref linkend="SetTitle"/>)
    </para>
  </listitem>
  <listitem>
    <para>
Image background color (<xref linkend="SetBackgroundColor"/>)
or image background file (<xref linkend="SetBgImage"/>)
    </para>
  </listitem>
  <listitem>
    <para>
Image border (<xref linkend="SetImageBorderColor"/> and
<xref linkend="SetImageBorderType"/>)
    </para>
  </listitem>
</itemizedlist>
For example, the first plot on an image that has a main title will result in
the main title being drawn. If any subsequent plot (using the same PHPlot
instance) also sets a main title, that will be ignored.
</para>
</sect3>

<sect3 id="adv-multiplot-datascale">
<title>Data Scaling</title>
<para>
Whether you use <xref linkend="SetPlotAreaWorld"/> to set the plot area
data range, or you let PHPlot calculate the plot area data range,
that range applies to all subsequent plots unless overridden.
Even if you set a new data array, the calculated or pre-set data range from
the previous plot applies. Without being told otherwise, PHPlot will not
re-examine the data array to recalculate the data range.
This allows you to re-use an automatically calculated date range, if you want.
  <note>
    <para>
Nothing related to world coordinates and data scaling applies to pie charts,
which have do not use world coordinates.
    </para>
  </note>
</para>
<para>
If instead you want PHPlot to automatically calculate the data range for
additional plots, call <literal>SetPlotAreaWorld()</literal> (with no
arguments), or <literal>SetPlotAreaWorld(NULL, NULL, NULL, NULL)</literal>.
Either of these forms causes PHPlot to forget about a specified or
calculated data range, and it will compute a new range.
</para>
<para>
Of course, you can also use <xref linkend="SetPlotAreaWorld"/> with
parameter values, to manually set all or part of the data range for each plot.
Any parameters you do not set (or specify as NULL) will be calculated based
on the data array for the current plot.
That is, PHPlot will forget about the previous data range once you call
<xref linkend="SetPlotAreaWorld"/>, regardless of how many non-NULL parameters
you use.
</para>
<para>
When overlaying plots, you will often want all the plots to use the same
data scale, so the values can be read off of the axis. Another option is to
have two separate Y scales, with one represented on the left side and one
on the right side. (See <xref linkend="ex-outbreak"/> for an example of
overlaying plots with two different Y scales.)
In some cases it may make sense to overlay plots with different scales and
no separate axis, for example when using data value labels, or when the
important information is the trend or shape shown by the graph rather than
the actual values.
</para>
</sect3>

<sect3 id="adv-multiplot-plotarea">
<title>Plot Area</title>
<para>
You can specify a plot area (window) with <xref linkend="SetPlotAreaPixels"/>
or <xref linkend="SetMarginsPixels"/>, or you can let PHPlot calculate a
plot area.
Whether you set the plot area yourself, or you let PHPlot calculate
it, those settings apply to all subsequent plots unless overridden.
</para>
<para>
This means that if you are doing side-by-side (tiled) plots on an image,
you must use <xref linkend="SetPlotAreaPixels"/> or
<xref linkend="SetMarginsPixels"/> with each plot, to set
the area of the image to be used for that plot.
Remember that the plot area does not include the axis labels, tick marks,
or titles, so you must leave enough room between and around plots for these.
</para>
<para>
If you are doing overlay plots, you can let PHPlot calculate the plot area
for the first plot, or you can specify the area with
<xref linkend="SetPlotAreaPixels"/> or <xref linkend="SetMarginsPixels"/>.
You need not use these for subsequent plots; PHPlot will continue to use the
same window, overlaying the additional plots.
</para>
<para>
However, if you allow PHPlot to calculate the plot area, it will only use
information in the first plot to determine the margins.
This will not work well if subsequent plots require more margin space.
For example, if the first plot has a Y axis title and tick labels only on the
left side, and the second overlay plot has a Y axis title and tick labels
on the right side, automatic plot area calculation will only leave enough
margin space on the left side.  As a result, the right side Y axis title and
tick labels may fall off the image edge.  To avoid this, use either
<xref linkend="SetPlotAreaPixels"/> or <xref linkend="SetMarginsPixels"/>
to specify large enough margins.
</para>
</sect3>

<sect3 id="adv-multiplot-ticks">
<title>Tick Increment</title>
<para>
Tick increments are recalculated for each plot, based on the data range, unless
set with <xref linkend="SetXTickIncrement"/>
or <xref linkend="SetYTickIncrement"/>.
'Data range' here refers to that set with <xref linkend="SetPlotAreaWorld"/>,
or automatically calculated.
This differs from the way PHPlot handles the data range, which is not
recalculated by default after the first plot.
</para>
<para>
For overlay plots, if you want to use the same tick increments,
you should either set the desired tick increment (doing this for the first
plot is sufficient), or make sure the data ranges match.
</para>
</sect3>

<sect3 id="adv-multiplot-grid">
<title>Grid Lines</title>
<para>
PHPlot defaults to drawing the dependent variable grid (usually Y), and the
grid lines will be drawn at tick positions.
As stated above, the tick positions by default will be recalculated for
each plot, using the calculated or explicitly set data range.
</para>
<para>
For overlay plots, you generally do not want to have more than one set of
grid lines in each of X and Y, or the results will be confusing.  Even if
your plot overlays have the same tick increments, avoid having the grid
lines drawn more than once. Otherwise, the grid lines for the second plot
will overlay the plotted data from the first plot.
You can turn off the grid lines with <literal>SetDrawXGrid(False)</literal>
and <literal>SetDrawYGrid(False)</literal>.
</para>
</sect3>

<sect3 id="adv-multiplot-legend">
<title>Legend Positioning</title>
<para>
Legend position with multiple plots works differently depending on whether
the position is defaulted or set, and if set what method was used.
<itemizedlist>
  <listitem>
    <para>
If the legend position is defaulted, a legend will be drawn at the upper
right corner of each plot.
The same legend will be drawn in each position, unless the contents are
changed with <xref linkend="SetLegend"/>.
    </para>
  </listitem>
  <listitem>
    <para>
If the legend position is specified using device coordinates with
<xref linkend="SetLegendPixels"/>, or by using
<xref linkend="SetLegendPosition"/> (PHPlot-5.4.0 or later) with mode 'image'
or 'title', then the legend position is relative to the image.
The legend will be drawn at the specified position on the image,
once per plot, at the same location.
This repeated over-drawing is usually harmless,
but if you want to have it drawn only once,
either use <xref linkend="SetLegend"/> only before the last plot,
or use either <literal>SetLegend(NULL)</literal>
or <literal>SetLegend(array())</literal>
to cancel the legend after the first plot.
    </para>
  </listitem>
  <listitem>
    <para>
If the legend position is specified using world coordinates with
<xref linkend="SetLegendWorld"/>, or by using
<xref linkend="SetLegendPosition"/> (PHPlot-5.4.0 or later) with mode 'world'
or 'plot', then the legend position is relative to the plot or the data
within the plot.
The legend will be drawn at the calculated position on each plot.
If using <xref linkend="SetLegendWorld"/>, or
<xref linkend="SetLegendPosition"/> with mode 'world', this assumes the
specified world coordinates are within the plot area for each plot.
As with the default positioning case, the same legend will be drawn for
each plot, unless the contents are changed with
<function>SetLegend()</function>.
    </para>
  </listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="adv-multiplot-background">
<title>Plot Area Background</title>

<para>
If you set a plot area background color with <xref linkend="SetPlotBgColor"/>
and <xref linkend="SetDrawPlotAreaBackground"/>,
or if you set a plot area background image with
<xref linkend="SetPlotAreaBgImage"/>,
this will be applied to each plot until disabled.
This works well for side-by-side (tiled) plots, as each will get the same
background by default.
</para>

<para>
If you are overlaying multiple plots on an image, setting a plot area
background color or image for one plot will result in that background
hiding previous plots. Therefore, you need to set up the background for the
first plot, then turn it off it for the second plot.
If you previously set a plot area background image, you can disable it for
subsequent plots with <literal>SetPlotAreaBgImage(NULL)</literal>.
If you previously set and enabled a plot area background color, you can
disable it for subsequent plots with
<literal>SetDrawPlotAreaBackground(FALSE)</literal>.
</para>
</sect3>

<sect3 id="adv-multiplot-axis">
<title>Axis Positioning</title>
<para>
You can position the X and Y axis manually with
<xref linkend="SetXAxisPosition"/> and <xref linkend="SetYAxisPosition"/>,
or you can let PHPlot calculate the axis positions for you.
Whether you set the positions yourself, or let PHPlot calculate them for you,
those positions apply to subsequent plots unless overridden.
Even if you set a new data array, PHPlot will not recalculate the axis
positions unless told to.
</para>
<para>
If you want PHPlot to automatically re-calculate the X axis position for a
subsequent plot, use <literal>SetXAxisPosition()</literal> (with no
arguments), or <literal>SetXAxisPosition('')</literal>.
To restore automatic Y axis position calculation, use
<literal>SetYAxisPosition()</literal>
or <literal>SetYAxisPosition('')</literal>.
</para>
</sect3>

</sect2>

<sect2 id="adv-multiplot-tiled">
<title>Summary - Tiled Multiple Plots</title>
<para>
Here are some guidelines for tiling multiple plots:
<itemizedlist>
  <listitem>
    <para>
Unless all plots will use the same X and Y data ranges, use
<xref linkend="SetPlotAreaWorld"/> with each plot.
Call the function with no arguments to have PHPlot automatically calculate
the data range for the plot, or supply arguments to explicitly set a data range.
    </para>
  </listitem>
  <listitem>
    <para>
Use <xref linkend="SetPlotAreaPixels"/> to set the area within the image
for each plot. Remember to leave room for axis labels and titles.
    </para>
  </listitem>
  <listitem>
    <para>
If you want a legend for each plot, use <xref linkend="SetLegendPixels"/>,
<xref linkend="SetLegendWorld"/>, or <xref linkend="SetLegendPosition"/>
to position it.
Or let the position default to the upper right corner of each plot.
If instead you want a single legend, for example outside all the plot areas,
either set it up for the last plot, or
set it up for any plot and cancel it for the next plot.
Position the single legend with <xref linkend="SetLegendPixels"/>,
or with <xref linkend="SetLegendPosition"/> using any mode except 'world'.
    </para>
  </listitem>
  <listitem>
    <para>
You can only have one main title for the entire image.
    </para>
  </listitem>
</itemizedlist>
</para>
</sect2>

<sect2 id="adv-multiplot-overlay">
<title>Summary - Overlay Multiple Plots</title>
<para>
Here are some guidelines for overlaying multiple plots:
<itemizedlist>
  <listitem>
    <para>
All plots will use the same data scaling by default, whether automatically
calculated by PHPlot or set with <xref linkend="SetPlotAreaWorld"/>.
Use <xref linkend="SetPlotAreaWorld"/> if you want different data scaling
for subsequent plots.
    </para>
  </listitem>
  <listitem>
    <para>
You can let PHPlot calculate the plot window by default, but it will not
account for additional margin space needed by plots after the first.
Instead, you can use <xref linkend="SetPlotAreaPixels"/> or
<xref linkend="SetMarginsPixels"/>
to set a specific plot area to use for all plots.
    </para>
  </listitem>
  <listitem>
    <para>
Set the tick increments you want for each plot, especially if the data
ranges differ. You can have two sets of tick marks and labels if you position
them on the opposite sides of the plot area.
    </para>
  </listitem>
  <listitem>
    <para>
Draw grid lines, if you want them, only for the first plot, and turn them
off for the second plot.
    </para>
  </listitem>
  <listitem>
    <para>
If you want a single legend, either set it up for the last plot, or
set it up for any plot and cancel it for the next plot.
If you want multiple legends, one per overlay, position them
manually with <xref linkend="SetLegendWorld"/>,
<xref linkend="SetLegendPixels"/>, or <xref linkend="SetLegendPosition"/>.
    </para>
  </listitem>
  <listitem>
    <para>
If you want a plot area background, you must set it for the first plot
and cancel it for the second plot, or it will hide the plots.
    </para>
  </listitem>
</itemizedlist>
</para>
</sect2>

<sect2 id="adv-multiplot-history">
<title>Multiple Plots - History</title>
<para>
A number of fixes were made in PHPlot-5.3.1 that affect multiple plots
per image. If you are creating multiple plot images using PHPlot-5.3.0 or
earlier, you should upgrade to the latest release. If you are unable to
upgrade, you may need to work around the following issues:

<itemizedlist>
  <listitem>
    <para>
Color allocation: In PHPlot-5.2.0 and PHPlot-5.3.0, the data color array
(whether defaulted or set with <xref linkend="SetDataColors"/>) was truncated
to the number of colors required for a plot.
This means that the additional colors were not available for subsequent plots,
so the data colors would repeat.
For example, if plot #1 used 3 colors for 3 data sets, and plot #2 had 5
data sets, only 3 colors were available and the first two colors would be
reused for the 4th and 5th data sets.
To work around this, you can reload the data colors before each subsequent plot.
To reload the default data colors, use
<literal>$plot->SetDataColors(False)</literal>.
Another work-around is to define a custom data color callback, which
turns off the color slot optimization.
    </para>
  </listitem>
  <listitem>
    <para>
Legend positioning using <xref linkend="SetLegendWorld"/> was not correctly
applied to subsequent plots in an image through PHPlot-5.3.0.
If you have multiple side-by-side plots and you want the legend in the same
world coordinate position in each plot, you still need to use
<literal>SetLegendWorld(..., ...)</literal> when creating each plot.
    </para>
  </listitem>
  <listitem>
    <para>
Through PHPlot-5.3.0, there was no way to reset the X axis position or Y
axis position to the default of automatic positioning.
That is, <literal>SetXAxisPosition()</literal>,
<literal>SetXAxisPosition('')</literal>,
<literal>SetYAxisPosition()</literal>,
and <literal>SetYAxisPosition('')</literal> did not work.
There is no work-around to get automatic positioning of the axis lines.
    </para>
  </listitem>
  <listitem>
    <para>
Through PHPlot-5.3.0, several functions had more restricted usage
when resetting to defaults.
      <itemizedlist>
        <listitem>
          <para>
Use <literal>SetLegendPixels(NULL, NULL)</literal>
rather than <literal>SetLegendPixels()</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
Use <literal>SetNumXTicks('')</literal> and <literal>SetNumYTicks('')</literal>
rather than <literal>SetNumXTicks()</literal> and
<literal>SetNumYTicks()</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
Use <literal>SetLegend(array())</literal>
rather than <literal>SetLegend(NULL)</literal>.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </listitem>
</itemizedlist>
</para>
</sect2>
</sect1> <!-- Multiple Plots -->

</chapter>
